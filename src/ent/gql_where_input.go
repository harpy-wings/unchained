// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/KenshiTech/unchained/src/ent/assetprice"
	"github.com/KenshiTech/unchained/src/ent/correctnessreport"
	"github.com/KenshiTech/unchained/src/ent/eventlog"
	"github.com/KenshiTech/unchained/src/ent/helpers"
	"github.com/KenshiTech/unchained/src/ent/predicate"
	"github.com/KenshiTech/unchained/src/ent/signer"
)

// AssetPriceWhereInput represents a where input for filtering AssetPrice queries.
type AssetPriceWhereInput struct {
	Predicates []predicate.AssetPrice  `json:"-"`
	Not        *AssetPriceWhereInput   `json:"not,omitempty"`
	Or         []*AssetPriceWhereInput `json:"or,omitempty"`
	And        []*AssetPriceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "block" field predicates.
	Block      *uint64  `json:"block,omitempty"`
	BlockNEQ   *uint64  `json:"blockNEQ,omitempty"`
	BlockIn    []uint64 `json:"blockIn,omitempty"`
	BlockNotIn []uint64 `json:"blockNotIn,omitempty"`
	BlockGT    *uint64  `json:"blockGT,omitempty"`
	BlockGTE   *uint64  `json:"blockGTE,omitempty"`
	BlockLT    *uint64  `json:"blockLT,omitempty"`
	BlockLTE   *uint64  `json:"blockLTE,omitempty"`

	// "signersCount" field predicates.
	SignersCount       *uint64  `json:"signerscount,omitempty"`
	SignersCountNEQ    *uint64  `json:"signerscountNEQ,omitempty"`
	SignersCountIn     []uint64 `json:"signerscountIn,omitempty"`
	SignersCountNotIn  []uint64 `json:"signerscountNotIn,omitempty"`
	SignersCountGT     *uint64  `json:"signerscountGT,omitempty"`
	SignersCountGTE    *uint64  `json:"signerscountGTE,omitempty"`
	SignersCountLT     *uint64  `json:"signerscountLT,omitempty"`
	SignersCountLTE    *uint64  `json:"signerscountLTE,omitempty"`
	SignersCountIsNil  bool     `json:"signerscountIsNil,omitempty"`
	SignersCountNotNil bool     `json:"signerscountNotNil,omitempty"`

	// "price" field predicates.
	Price      *helpers.BigInt   `json:"price,omitempty"`
	PriceNEQ   *helpers.BigInt   `json:"priceNEQ,omitempty"`
	PriceIn    []*helpers.BigInt `json:"priceIn,omitempty"`
	PriceNotIn []*helpers.BigInt `json:"priceNotIn,omitempty"`
	PriceGT    *helpers.BigInt   `json:"priceGT,omitempty"`
	PriceGTE   *helpers.BigInt   `json:"priceGTE,omitempty"`
	PriceLT    *helpers.BigInt   `json:"priceLT,omitempty"`
	PriceLTE   *helpers.BigInt   `json:"priceLTE,omitempty"`

	// "asset" field predicates.
	Asset             *string  `json:"asset,omitempty"`
	AssetNEQ          *string  `json:"assetNEQ,omitempty"`
	AssetIn           []string `json:"assetIn,omitempty"`
	AssetNotIn        []string `json:"assetNotIn,omitempty"`
	AssetGT           *string  `json:"assetGT,omitempty"`
	AssetGTE          *string  `json:"assetGTE,omitempty"`
	AssetLT           *string  `json:"assetLT,omitempty"`
	AssetLTE          *string  `json:"assetLTE,omitempty"`
	AssetContains     *string  `json:"assetContains,omitempty"`
	AssetHasPrefix    *string  `json:"assetHasPrefix,omitempty"`
	AssetHasSuffix    *string  `json:"assetHasSuffix,omitempty"`
	AssetIsNil        bool     `json:"assetIsNil,omitempty"`
	AssetNotNil       bool     `json:"assetNotNil,omitempty"`
	AssetEqualFold    *string  `json:"assetEqualFold,omitempty"`
	AssetContainsFold *string  `json:"assetContainsFold,omitempty"`

	// "chain" field predicates.
	Chain             *string  `json:"chain,omitempty"`
	ChainNEQ          *string  `json:"chainNEQ,omitempty"`
	ChainIn           []string `json:"chainIn,omitempty"`
	ChainNotIn        []string `json:"chainNotIn,omitempty"`
	ChainGT           *string  `json:"chainGT,omitempty"`
	ChainGTE          *string  `json:"chainGTE,omitempty"`
	ChainLT           *string  `json:"chainLT,omitempty"`
	ChainLTE          *string  `json:"chainLTE,omitempty"`
	ChainContains     *string  `json:"chainContains,omitempty"`
	ChainHasPrefix    *string  `json:"chainHasPrefix,omitempty"`
	ChainHasSuffix    *string  `json:"chainHasSuffix,omitempty"`
	ChainIsNil        bool     `json:"chainIsNil,omitempty"`
	ChainNotNil       bool     `json:"chainNotNil,omitempty"`
	ChainEqualFold    *string  `json:"chainEqualFold,omitempty"`
	ChainContainsFold *string  `json:"chainContainsFold,omitempty"`

	// "pair" field predicates.
	Pair             *string  `json:"pair,omitempty"`
	PairNEQ          *string  `json:"pairNEQ,omitempty"`
	PairIn           []string `json:"pairIn,omitempty"`
	PairNotIn        []string `json:"pairNotIn,omitempty"`
	PairGT           *string  `json:"pairGT,omitempty"`
	PairGTE          *string  `json:"pairGTE,omitempty"`
	PairLT           *string  `json:"pairLT,omitempty"`
	PairLTE          *string  `json:"pairLTE,omitempty"`
	PairContains     *string  `json:"pairContains,omitempty"`
	PairHasPrefix    *string  `json:"pairHasPrefix,omitempty"`
	PairHasSuffix    *string  `json:"pairHasSuffix,omitempty"`
	PairIsNil        bool     `json:"pairIsNil,omitempty"`
	PairNotNil       bool     `json:"pairNotNil,omitempty"`
	PairEqualFold    *string  `json:"pairEqualFold,omitempty"`
	PairContainsFold *string  `json:"pairContainsFold,omitempty"`

	// "signers" edge predicates.
	HasSigners     *bool               `json:"hasSigners,omitempty"`
	HasSignersWith []*SignerWhereInput `json:"hasSignersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AssetPriceWhereInput) AddPredicates(predicates ...predicate.AssetPrice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AssetPriceWhereInput filter on the AssetPriceQuery builder.
func (i *AssetPriceWhereInput) Filter(q *AssetPriceQuery) (*AssetPriceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAssetPriceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAssetPriceWhereInput is returned in case the AssetPriceWhereInput is empty.
var ErrEmptyAssetPriceWhereInput = errors.New("ent: empty predicate AssetPriceWhereInput")

// P returns a predicate for filtering assetprices.
// An error is returned if the input is empty or invalid.
func (i *AssetPriceWhereInput) P() (predicate.AssetPrice, error) {
	var predicates []predicate.AssetPrice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, assetprice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AssetPrice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, assetprice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AssetPrice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, assetprice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, assetprice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, assetprice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, assetprice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, assetprice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, assetprice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, assetprice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, assetprice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, assetprice.IDLTE(*i.IDLTE))
	}
	if i.Block != nil {
		predicates = append(predicates, assetprice.BlockEQ(*i.Block))
	}
	if i.BlockNEQ != nil {
		predicates = append(predicates, assetprice.BlockNEQ(*i.BlockNEQ))
	}
	if len(i.BlockIn) > 0 {
		predicates = append(predicates, assetprice.BlockIn(i.BlockIn...))
	}
	if len(i.BlockNotIn) > 0 {
		predicates = append(predicates, assetprice.BlockNotIn(i.BlockNotIn...))
	}
	if i.BlockGT != nil {
		predicates = append(predicates, assetprice.BlockGT(*i.BlockGT))
	}
	if i.BlockGTE != nil {
		predicates = append(predicates, assetprice.BlockGTE(*i.BlockGTE))
	}
	if i.BlockLT != nil {
		predicates = append(predicates, assetprice.BlockLT(*i.BlockLT))
	}
	if i.BlockLTE != nil {
		predicates = append(predicates, assetprice.BlockLTE(*i.BlockLTE))
	}
	if i.SignersCount != nil {
		predicates = append(predicates, assetprice.SignersCountEQ(*i.SignersCount))
	}
	if i.SignersCountNEQ != nil {
		predicates = append(predicates, assetprice.SignersCountNEQ(*i.SignersCountNEQ))
	}
	if len(i.SignersCountIn) > 0 {
		predicates = append(predicates, assetprice.SignersCountIn(i.SignersCountIn...))
	}
	if len(i.SignersCountNotIn) > 0 {
		predicates = append(predicates, assetprice.SignersCountNotIn(i.SignersCountNotIn...))
	}
	if i.SignersCountGT != nil {
		predicates = append(predicates, assetprice.SignersCountGT(*i.SignersCountGT))
	}
	if i.SignersCountGTE != nil {
		predicates = append(predicates, assetprice.SignersCountGTE(*i.SignersCountGTE))
	}
	if i.SignersCountLT != nil {
		predicates = append(predicates, assetprice.SignersCountLT(*i.SignersCountLT))
	}
	if i.SignersCountLTE != nil {
		predicates = append(predicates, assetprice.SignersCountLTE(*i.SignersCountLTE))
	}
	if i.SignersCountIsNil {
		predicates = append(predicates, assetprice.SignersCountIsNil())
	}
	if i.SignersCountNotNil {
		predicates = append(predicates, assetprice.SignersCountNotNil())
	}
	if i.Price != nil {
		predicates = append(predicates, assetprice.PriceEQ(i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, assetprice.PriceNEQ(i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, assetprice.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, assetprice.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, assetprice.PriceGT(i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, assetprice.PriceGTE(i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, assetprice.PriceLT(i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, assetprice.PriceLTE(i.PriceLTE))
	}
	if i.Asset != nil {
		predicates = append(predicates, assetprice.AssetEQ(*i.Asset))
	}
	if i.AssetNEQ != nil {
		predicates = append(predicates, assetprice.AssetNEQ(*i.AssetNEQ))
	}
	if len(i.AssetIn) > 0 {
		predicates = append(predicates, assetprice.AssetIn(i.AssetIn...))
	}
	if len(i.AssetNotIn) > 0 {
		predicates = append(predicates, assetprice.AssetNotIn(i.AssetNotIn...))
	}
	if i.AssetGT != nil {
		predicates = append(predicates, assetprice.AssetGT(*i.AssetGT))
	}
	if i.AssetGTE != nil {
		predicates = append(predicates, assetprice.AssetGTE(*i.AssetGTE))
	}
	if i.AssetLT != nil {
		predicates = append(predicates, assetprice.AssetLT(*i.AssetLT))
	}
	if i.AssetLTE != nil {
		predicates = append(predicates, assetprice.AssetLTE(*i.AssetLTE))
	}
	if i.AssetContains != nil {
		predicates = append(predicates, assetprice.AssetContains(*i.AssetContains))
	}
	if i.AssetHasPrefix != nil {
		predicates = append(predicates, assetprice.AssetHasPrefix(*i.AssetHasPrefix))
	}
	if i.AssetHasSuffix != nil {
		predicates = append(predicates, assetprice.AssetHasSuffix(*i.AssetHasSuffix))
	}
	if i.AssetIsNil {
		predicates = append(predicates, assetprice.AssetIsNil())
	}
	if i.AssetNotNil {
		predicates = append(predicates, assetprice.AssetNotNil())
	}
	if i.AssetEqualFold != nil {
		predicates = append(predicates, assetprice.AssetEqualFold(*i.AssetEqualFold))
	}
	if i.AssetContainsFold != nil {
		predicates = append(predicates, assetprice.AssetContainsFold(*i.AssetContainsFold))
	}
	if i.Chain != nil {
		predicates = append(predicates, assetprice.ChainEQ(*i.Chain))
	}
	if i.ChainNEQ != nil {
		predicates = append(predicates, assetprice.ChainNEQ(*i.ChainNEQ))
	}
	if len(i.ChainIn) > 0 {
		predicates = append(predicates, assetprice.ChainIn(i.ChainIn...))
	}
	if len(i.ChainNotIn) > 0 {
		predicates = append(predicates, assetprice.ChainNotIn(i.ChainNotIn...))
	}
	if i.ChainGT != nil {
		predicates = append(predicates, assetprice.ChainGT(*i.ChainGT))
	}
	if i.ChainGTE != nil {
		predicates = append(predicates, assetprice.ChainGTE(*i.ChainGTE))
	}
	if i.ChainLT != nil {
		predicates = append(predicates, assetprice.ChainLT(*i.ChainLT))
	}
	if i.ChainLTE != nil {
		predicates = append(predicates, assetprice.ChainLTE(*i.ChainLTE))
	}
	if i.ChainContains != nil {
		predicates = append(predicates, assetprice.ChainContains(*i.ChainContains))
	}
	if i.ChainHasPrefix != nil {
		predicates = append(predicates, assetprice.ChainHasPrefix(*i.ChainHasPrefix))
	}
	if i.ChainHasSuffix != nil {
		predicates = append(predicates, assetprice.ChainHasSuffix(*i.ChainHasSuffix))
	}
	if i.ChainIsNil {
		predicates = append(predicates, assetprice.ChainIsNil())
	}
	if i.ChainNotNil {
		predicates = append(predicates, assetprice.ChainNotNil())
	}
	if i.ChainEqualFold != nil {
		predicates = append(predicates, assetprice.ChainEqualFold(*i.ChainEqualFold))
	}
	if i.ChainContainsFold != nil {
		predicates = append(predicates, assetprice.ChainContainsFold(*i.ChainContainsFold))
	}
	if i.Pair != nil {
		predicates = append(predicates, assetprice.PairEQ(*i.Pair))
	}
	if i.PairNEQ != nil {
		predicates = append(predicates, assetprice.PairNEQ(*i.PairNEQ))
	}
	if len(i.PairIn) > 0 {
		predicates = append(predicates, assetprice.PairIn(i.PairIn...))
	}
	if len(i.PairNotIn) > 0 {
		predicates = append(predicates, assetprice.PairNotIn(i.PairNotIn...))
	}
	if i.PairGT != nil {
		predicates = append(predicates, assetprice.PairGT(*i.PairGT))
	}
	if i.PairGTE != nil {
		predicates = append(predicates, assetprice.PairGTE(*i.PairGTE))
	}
	if i.PairLT != nil {
		predicates = append(predicates, assetprice.PairLT(*i.PairLT))
	}
	if i.PairLTE != nil {
		predicates = append(predicates, assetprice.PairLTE(*i.PairLTE))
	}
	if i.PairContains != nil {
		predicates = append(predicates, assetprice.PairContains(*i.PairContains))
	}
	if i.PairHasPrefix != nil {
		predicates = append(predicates, assetprice.PairHasPrefix(*i.PairHasPrefix))
	}
	if i.PairHasSuffix != nil {
		predicates = append(predicates, assetprice.PairHasSuffix(*i.PairHasSuffix))
	}
	if i.PairIsNil {
		predicates = append(predicates, assetprice.PairIsNil())
	}
	if i.PairNotNil {
		predicates = append(predicates, assetprice.PairNotNil())
	}
	if i.PairEqualFold != nil {
		predicates = append(predicates, assetprice.PairEqualFold(*i.PairEqualFold))
	}
	if i.PairContainsFold != nil {
		predicates = append(predicates, assetprice.PairContainsFold(*i.PairContainsFold))
	}

	if i.HasSigners != nil {
		p := assetprice.HasSigners()
		if !*i.HasSigners {
			p = assetprice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignersWith) > 0 {
		with := make([]predicate.Signer, 0, len(i.HasSignersWith))
		for _, w := range i.HasSignersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, assetprice.HasSignersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAssetPriceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return assetprice.And(predicates...), nil
	}
}

// CorrectnessReportWhereInput represents a where input for filtering CorrectnessReport queries.
type CorrectnessReportWhereInput struct {
	Predicates []predicate.CorrectnessReport  `json:"-"`
	Not        *CorrectnessReportWhereInput   `json:"not,omitempty"`
	Or         []*CorrectnessReportWhereInput `json:"or,omitempty"`
	And        []*CorrectnessReportWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "signersCount" field predicates.
	SignersCount      *uint64  `json:"signerscount,omitempty"`
	SignersCountNEQ   *uint64  `json:"signerscountNEQ,omitempty"`
	SignersCountIn    []uint64 `json:"signerscountIn,omitempty"`
	SignersCountNotIn []uint64 `json:"signerscountNotIn,omitempty"`
	SignersCountGT    *uint64  `json:"signerscountGT,omitempty"`
	SignersCountGTE   *uint64  `json:"signerscountGTE,omitempty"`
	SignersCountLT    *uint64  `json:"signerscountLT,omitempty"`
	SignersCountLTE   *uint64  `json:"signerscountLTE,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *uint64  `json:"timestamp,omitempty"`
	TimestampNEQ   *uint64  `json:"timestampNEQ,omitempty"`
	TimestampIn    []uint64 `json:"timestampIn,omitempty"`
	TimestampNotIn []uint64 `json:"timestampNotIn,omitempty"`
	TimestampGT    *uint64  `json:"timestampGT,omitempty"`
	TimestampGTE   *uint64  `json:"timestampGTE,omitempty"`
	TimestampLT    *uint64  `json:"timestampLT,omitempty"`
	TimestampLTE   *uint64  `json:"timestampLTE,omitempty"`

	// "correct" field predicates.
	Correct    *bool `json:"correct,omitempty"`
	CorrectNEQ *bool `json:"correctNEQ,omitempty"`

	// "signers" edge predicates.
	HasSigners     *bool               `json:"hasSigners,omitempty"`
	HasSignersWith []*SignerWhereInput `json:"hasSignersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CorrectnessReportWhereInput) AddPredicates(predicates ...predicate.CorrectnessReport) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CorrectnessReportWhereInput filter on the CorrectnessReportQuery builder.
func (i *CorrectnessReportWhereInput) Filter(q *CorrectnessReportQuery) (*CorrectnessReportQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCorrectnessReportWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCorrectnessReportWhereInput is returned in case the CorrectnessReportWhereInput is empty.
var ErrEmptyCorrectnessReportWhereInput = errors.New("ent: empty predicate CorrectnessReportWhereInput")

// P returns a predicate for filtering correctnessreports.
// An error is returned if the input is empty or invalid.
func (i *CorrectnessReportWhereInput) P() (predicate.CorrectnessReport, error) {
	var predicates []predicate.CorrectnessReport
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, correctnessreport.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CorrectnessReport, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, correctnessreport.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CorrectnessReport, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, correctnessreport.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, correctnessreport.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, correctnessreport.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, correctnessreport.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, correctnessreport.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, correctnessreport.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, correctnessreport.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, correctnessreport.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, correctnessreport.IDLTE(*i.IDLTE))
	}
	if i.SignersCount != nil {
		predicates = append(predicates, correctnessreport.SignersCountEQ(*i.SignersCount))
	}
	if i.SignersCountNEQ != nil {
		predicates = append(predicates, correctnessreport.SignersCountNEQ(*i.SignersCountNEQ))
	}
	if len(i.SignersCountIn) > 0 {
		predicates = append(predicates, correctnessreport.SignersCountIn(i.SignersCountIn...))
	}
	if len(i.SignersCountNotIn) > 0 {
		predicates = append(predicates, correctnessreport.SignersCountNotIn(i.SignersCountNotIn...))
	}
	if i.SignersCountGT != nil {
		predicates = append(predicates, correctnessreport.SignersCountGT(*i.SignersCountGT))
	}
	if i.SignersCountGTE != nil {
		predicates = append(predicates, correctnessreport.SignersCountGTE(*i.SignersCountGTE))
	}
	if i.SignersCountLT != nil {
		predicates = append(predicates, correctnessreport.SignersCountLT(*i.SignersCountLT))
	}
	if i.SignersCountLTE != nil {
		predicates = append(predicates, correctnessreport.SignersCountLTE(*i.SignersCountLTE))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, correctnessreport.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, correctnessreport.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, correctnessreport.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, correctnessreport.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, correctnessreport.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, correctnessreport.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, correctnessreport.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, correctnessreport.TimestampLTE(*i.TimestampLTE))
	}
	if i.Correct != nil {
		predicates = append(predicates, correctnessreport.CorrectEQ(*i.Correct))
	}
	if i.CorrectNEQ != nil {
		predicates = append(predicates, correctnessreport.CorrectNEQ(*i.CorrectNEQ))
	}

	if i.HasSigners != nil {
		p := correctnessreport.HasSigners()
		if !*i.HasSigners {
			p = correctnessreport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignersWith) > 0 {
		with := make([]predicate.Signer, 0, len(i.HasSignersWith))
		for _, w := range i.HasSignersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, correctnessreport.HasSignersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCorrectnessReportWhereInput
	case 1:
		return predicates[0], nil
	default:
		return correctnessreport.And(predicates...), nil
	}
}

// EventLogWhereInput represents a where input for filtering EventLog queries.
type EventLogWhereInput struct {
	Predicates []predicate.EventLog  `json:"-"`
	Not        *EventLogWhereInput   `json:"not,omitempty"`
	Or         []*EventLogWhereInput `json:"or,omitempty"`
	And        []*EventLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "block" field predicates.
	Block      *uint64  `json:"block,omitempty"`
	BlockNEQ   *uint64  `json:"blockNEQ,omitempty"`
	BlockIn    []uint64 `json:"blockIn,omitempty"`
	BlockNotIn []uint64 `json:"blockNotIn,omitempty"`
	BlockGT    *uint64  `json:"blockGT,omitempty"`
	BlockGTE   *uint64  `json:"blockGTE,omitempty"`
	BlockLT    *uint64  `json:"blockLT,omitempty"`
	BlockLTE   *uint64  `json:"blockLTE,omitempty"`

	// "signersCount" field predicates.
	SignersCount      *uint64  `json:"signerscount,omitempty"`
	SignersCountNEQ   *uint64  `json:"signerscountNEQ,omitempty"`
	SignersCountIn    []uint64 `json:"signerscountIn,omitempty"`
	SignersCountNotIn []uint64 `json:"signerscountNotIn,omitempty"`
	SignersCountGT    *uint64  `json:"signerscountGT,omitempty"`
	SignersCountGTE   *uint64  `json:"signerscountGTE,omitempty"`
	SignersCountLT    *uint64  `json:"signerscountLT,omitempty"`
	SignersCountLTE   *uint64  `json:"signerscountLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "chain" field predicates.
	Chain             *string  `json:"chain,omitempty"`
	ChainNEQ          *string  `json:"chainNEQ,omitempty"`
	ChainIn           []string `json:"chainIn,omitempty"`
	ChainNotIn        []string `json:"chainNotIn,omitempty"`
	ChainGT           *string  `json:"chainGT,omitempty"`
	ChainGTE          *string  `json:"chainGTE,omitempty"`
	ChainLT           *string  `json:"chainLT,omitempty"`
	ChainLTE          *string  `json:"chainLTE,omitempty"`
	ChainContains     *string  `json:"chainContains,omitempty"`
	ChainHasPrefix    *string  `json:"chainHasPrefix,omitempty"`
	ChainHasSuffix    *string  `json:"chainHasSuffix,omitempty"`
	ChainEqualFold    *string  `json:"chainEqualFold,omitempty"`
	ChainContainsFold *string  `json:"chainContainsFold,omitempty"`

	// "index" field predicates.
	Index      *uint64  `json:"index,omitempty"`
	IndexNEQ   *uint64  `json:"indexNEQ,omitempty"`
	IndexIn    []uint64 `json:"indexIn,omitempty"`
	IndexNotIn []uint64 `json:"indexNotIn,omitempty"`
	IndexGT    *uint64  `json:"indexGT,omitempty"`
	IndexGTE   *uint64  `json:"indexGTE,omitempty"`
	IndexLT    *uint64  `json:"indexLT,omitempty"`
	IndexLTE   *uint64  `json:"indexLTE,omitempty"`

	// "event" field predicates.
	Event             *string  `json:"event,omitempty"`
	EventNEQ          *string  `json:"eventNEQ,omitempty"`
	EventIn           []string `json:"eventIn,omitempty"`
	EventNotIn        []string `json:"eventNotIn,omitempty"`
	EventGT           *string  `json:"eventGT,omitempty"`
	EventGTE          *string  `json:"eventGTE,omitempty"`
	EventLT           *string  `json:"eventLT,omitempty"`
	EventLTE          *string  `json:"eventLTE,omitempty"`
	EventContains     *string  `json:"eventContains,omitempty"`
	EventHasPrefix    *string  `json:"eventHasPrefix,omitempty"`
	EventHasSuffix    *string  `json:"eventHasSuffix,omitempty"`
	EventEqualFold    *string  `json:"eventEqualFold,omitempty"`
	EventContainsFold *string  `json:"eventContainsFold,omitempty"`

	// "signers" edge predicates.
	HasSigners     *bool               `json:"hasSigners,omitempty"`
	HasSignersWith []*SignerWhereInput `json:"hasSignersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EventLogWhereInput) AddPredicates(predicates ...predicate.EventLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EventLogWhereInput filter on the EventLogQuery builder.
func (i *EventLogWhereInput) Filter(q *EventLogQuery) (*EventLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEventLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEventLogWhereInput is returned in case the EventLogWhereInput is empty.
var ErrEmptyEventLogWhereInput = errors.New("ent: empty predicate EventLogWhereInput")

// P returns a predicate for filtering eventlogs.
// An error is returned if the input is empty or invalid.
func (i *EventLogWhereInput) P() (predicate.EventLog, error) {
	var predicates []predicate.EventLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, eventlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EventLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, eventlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EventLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, eventlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, eventlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, eventlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, eventlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, eventlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, eventlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, eventlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, eventlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, eventlog.IDLTE(*i.IDLTE))
	}
	if i.Block != nil {
		predicates = append(predicates, eventlog.BlockEQ(*i.Block))
	}
	if i.BlockNEQ != nil {
		predicates = append(predicates, eventlog.BlockNEQ(*i.BlockNEQ))
	}
	if len(i.BlockIn) > 0 {
		predicates = append(predicates, eventlog.BlockIn(i.BlockIn...))
	}
	if len(i.BlockNotIn) > 0 {
		predicates = append(predicates, eventlog.BlockNotIn(i.BlockNotIn...))
	}
	if i.BlockGT != nil {
		predicates = append(predicates, eventlog.BlockGT(*i.BlockGT))
	}
	if i.BlockGTE != nil {
		predicates = append(predicates, eventlog.BlockGTE(*i.BlockGTE))
	}
	if i.BlockLT != nil {
		predicates = append(predicates, eventlog.BlockLT(*i.BlockLT))
	}
	if i.BlockLTE != nil {
		predicates = append(predicates, eventlog.BlockLTE(*i.BlockLTE))
	}
	if i.SignersCount != nil {
		predicates = append(predicates, eventlog.SignersCountEQ(*i.SignersCount))
	}
	if i.SignersCountNEQ != nil {
		predicates = append(predicates, eventlog.SignersCountNEQ(*i.SignersCountNEQ))
	}
	if len(i.SignersCountIn) > 0 {
		predicates = append(predicates, eventlog.SignersCountIn(i.SignersCountIn...))
	}
	if len(i.SignersCountNotIn) > 0 {
		predicates = append(predicates, eventlog.SignersCountNotIn(i.SignersCountNotIn...))
	}
	if i.SignersCountGT != nil {
		predicates = append(predicates, eventlog.SignersCountGT(*i.SignersCountGT))
	}
	if i.SignersCountGTE != nil {
		predicates = append(predicates, eventlog.SignersCountGTE(*i.SignersCountGTE))
	}
	if i.SignersCountLT != nil {
		predicates = append(predicates, eventlog.SignersCountLT(*i.SignersCountLT))
	}
	if i.SignersCountLTE != nil {
		predicates = append(predicates, eventlog.SignersCountLTE(*i.SignersCountLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, eventlog.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, eventlog.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, eventlog.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, eventlog.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, eventlog.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, eventlog.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, eventlog.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, eventlog.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, eventlog.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, eventlog.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, eventlog.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, eventlog.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, eventlog.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Chain != nil {
		predicates = append(predicates, eventlog.ChainEQ(*i.Chain))
	}
	if i.ChainNEQ != nil {
		predicates = append(predicates, eventlog.ChainNEQ(*i.ChainNEQ))
	}
	if len(i.ChainIn) > 0 {
		predicates = append(predicates, eventlog.ChainIn(i.ChainIn...))
	}
	if len(i.ChainNotIn) > 0 {
		predicates = append(predicates, eventlog.ChainNotIn(i.ChainNotIn...))
	}
	if i.ChainGT != nil {
		predicates = append(predicates, eventlog.ChainGT(*i.ChainGT))
	}
	if i.ChainGTE != nil {
		predicates = append(predicates, eventlog.ChainGTE(*i.ChainGTE))
	}
	if i.ChainLT != nil {
		predicates = append(predicates, eventlog.ChainLT(*i.ChainLT))
	}
	if i.ChainLTE != nil {
		predicates = append(predicates, eventlog.ChainLTE(*i.ChainLTE))
	}
	if i.ChainContains != nil {
		predicates = append(predicates, eventlog.ChainContains(*i.ChainContains))
	}
	if i.ChainHasPrefix != nil {
		predicates = append(predicates, eventlog.ChainHasPrefix(*i.ChainHasPrefix))
	}
	if i.ChainHasSuffix != nil {
		predicates = append(predicates, eventlog.ChainHasSuffix(*i.ChainHasSuffix))
	}
	if i.ChainEqualFold != nil {
		predicates = append(predicates, eventlog.ChainEqualFold(*i.ChainEqualFold))
	}
	if i.ChainContainsFold != nil {
		predicates = append(predicates, eventlog.ChainContainsFold(*i.ChainContainsFold))
	}
	if i.Index != nil {
		predicates = append(predicates, eventlog.IndexEQ(*i.Index))
	}
	if i.IndexNEQ != nil {
		predicates = append(predicates, eventlog.IndexNEQ(*i.IndexNEQ))
	}
	if len(i.IndexIn) > 0 {
		predicates = append(predicates, eventlog.IndexIn(i.IndexIn...))
	}
	if len(i.IndexNotIn) > 0 {
		predicates = append(predicates, eventlog.IndexNotIn(i.IndexNotIn...))
	}
	if i.IndexGT != nil {
		predicates = append(predicates, eventlog.IndexGT(*i.IndexGT))
	}
	if i.IndexGTE != nil {
		predicates = append(predicates, eventlog.IndexGTE(*i.IndexGTE))
	}
	if i.IndexLT != nil {
		predicates = append(predicates, eventlog.IndexLT(*i.IndexLT))
	}
	if i.IndexLTE != nil {
		predicates = append(predicates, eventlog.IndexLTE(*i.IndexLTE))
	}
	if i.Event != nil {
		predicates = append(predicates, eventlog.EventEQ(*i.Event))
	}
	if i.EventNEQ != nil {
		predicates = append(predicates, eventlog.EventNEQ(*i.EventNEQ))
	}
	if len(i.EventIn) > 0 {
		predicates = append(predicates, eventlog.EventIn(i.EventIn...))
	}
	if len(i.EventNotIn) > 0 {
		predicates = append(predicates, eventlog.EventNotIn(i.EventNotIn...))
	}
	if i.EventGT != nil {
		predicates = append(predicates, eventlog.EventGT(*i.EventGT))
	}
	if i.EventGTE != nil {
		predicates = append(predicates, eventlog.EventGTE(*i.EventGTE))
	}
	if i.EventLT != nil {
		predicates = append(predicates, eventlog.EventLT(*i.EventLT))
	}
	if i.EventLTE != nil {
		predicates = append(predicates, eventlog.EventLTE(*i.EventLTE))
	}
	if i.EventContains != nil {
		predicates = append(predicates, eventlog.EventContains(*i.EventContains))
	}
	if i.EventHasPrefix != nil {
		predicates = append(predicates, eventlog.EventHasPrefix(*i.EventHasPrefix))
	}
	if i.EventHasSuffix != nil {
		predicates = append(predicates, eventlog.EventHasSuffix(*i.EventHasSuffix))
	}
	if i.EventEqualFold != nil {
		predicates = append(predicates, eventlog.EventEqualFold(*i.EventEqualFold))
	}
	if i.EventContainsFold != nil {
		predicates = append(predicates, eventlog.EventContainsFold(*i.EventContainsFold))
	}

	if i.HasSigners != nil {
		p := eventlog.HasSigners()
		if !*i.HasSigners {
			p = eventlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignersWith) > 0 {
		with := make([]predicate.Signer, 0, len(i.HasSignersWith))
		for _, w := range i.HasSignersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, eventlog.HasSignersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEventLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return eventlog.And(predicates...), nil
	}
}

// SignerWhereInput represents a where input for filtering Signer queries.
type SignerWhereInput struct {
	Predicates []predicate.Signer  `json:"-"`
	Not        *SignerWhereInput   `json:"not,omitempty"`
	Or         []*SignerWhereInput `json:"or,omitempty"`
	And        []*SignerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "evm" field predicates.
	Evm             *string  `json:"evm,omitempty"`
	EvmNEQ          *string  `json:"evmNEQ,omitempty"`
	EvmIn           []string `json:"evmIn,omitempty"`
	EvmNotIn        []string `json:"evmNotIn,omitempty"`
	EvmGT           *string  `json:"evmGT,omitempty"`
	EvmGTE          *string  `json:"evmGTE,omitempty"`
	EvmLT           *string  `json:"evmLT,omitempty"`
	EvmLTE          *string  `json:"evmLTE,omitempty"`
	EvmContains     *string  `json:"evmContains,omitempty"`
	EvmHasPrefix    *string  `json:"evmHasPrefix,omitempty"`
	EvmHasSuffix    *string  `json:"evmHasSuffix,omitempty"`
	EvmIsNil        bool     `json:"evmIsNil,omitempty"`
	EvmNotNil       bool     `json:"evmNotNil,omitempty"`
	EvmEqualFold    *string  `json:"evmEqualFold,omitempty"`
	EvmContainsFold *string  `json:"evmContainsFold,omitempty"`

	// "points" field predicates.
	Points      *int64  `json:"points,omitempty"`
	PointsNEQ   *int64  `json:"pointsNEQ,omitempty"`
	PointsIn    []int64 `json:"pointsIn,omitempty"`
	PointsNotIn []int64 `json:"pointsNotIn,omitempty"`
	PointsGT    *int64  `json:"pointsGT,omitempty"`
	PointsGTE   *int64  `json:"pointsGTE,omitempty"`
	PointsLT    *int64  `json:"pointsLT,omitempty"`
	PointsLTE   *int64  `json:"pointsLTE,omitempty"`

	// "assetPrice" edge predicates.
	HasAssetPrice     *bool                   `json:"hasAssetPrice,omitempty"`
	HasAssetPriceWith []*AssetPriceWhereInput `json:"hasAssetPriceWith,omitempty"`

	// "eventLogs" edge predicates.
	HasEventLogs     *bool                 `json:"hasEventLogs,omitempty"`
	HasEventLogsWith []*EventLogWhereInput `json:"hasEventLogsWith,omitempty"`

	// "correctnessReport" edge predicates.
	HasCorrectnessReport     *bool                          `json:"hasCorrectnessReport,omitempty"`
	HasCorrectnessReportWith []*CorrectnessReportWhereInput `json:"hasCorrectnessReportWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SignerWhereInput) AddPredicates(predicates ...predicate.Signer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SignerWhereInput filter on the SignerQuery builder.
func (i *SignerWhereInput) Filter(q *SignerQuery) (*SignerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySignerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySignerWhereInput is returned in case the SignerWhereInput is empty.
var ErrEmptySignerWhereInput = errors.New("ent: empty predicate SignerWhereInput")

// P returns a predicate for filtering signers.
// An error is returned if the input is empty or invalid.
func (i *SignerWhereInput) P() (predicate.Signer, error) {
	var predicates []predicate.Signer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, signer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Signer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, signer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Signer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, signer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, signer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, signer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, signer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, signer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, signer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, signer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, signer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, signer.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, signer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, signer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, signer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, signer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, signer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, signer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, signer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, signer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, signer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, signer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, signer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, signer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, signer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Evm != nil {
		predicates = append(predicates, signer.EvmEQ(*i.Evm))
	}
	if i.EvmNEQ != nil {
		predicates = append(predicates, signer.EvmNEQ(*i.EvmNEQ))
	}
	if len(i.EvmIn) > 0 {
		predicates = append(predicates, signer.EvmIn(i.EvmIn...))
	}
	if len(i.EvmNotIn) > 0 {
		predicates = append(predicates, signer.EvmNotIn(i.EvmNotIn...))
	}
	if i.EvmGT != nil {
		predicates = append(predicates, signer.EvmGT(*i.EvmGT))
	}
	if i.EvmGTE != nil {
		predicates = append(predicates, signer.EvmGTE(*i.EvmGTE))
	}
	if i.EvmLT != nil {
		predicates = append(predicates, signer.EvmLT(*i.EvmLT))
	}
	if i.EvmLTE != nil {
		predicates = append(predicates, signer.EvmLTE(*i.EvmLTE))
	}
	if i.EvmContains != nil {
		predicates = append(predicates, signer.EvmContains(*i.EvmContains))
	}
	if i.EvmHasPrefix != nil {
		predicates = append(predicates, signer.EvmHasPrefix(*i.EvmHasPrefix))
	}
	if i.EvmHasSuffix != nil {
		predicates = append(predicates, signer.EvmHasSuffix(*i.EvmHasSuffix))
	}
	if i.EvmIsNil {
		predicates = append(predicates, signer.EvmIsNil())
	}
	if i.EvmNotNil {
		predicates = append(predicates, signer.EvmNotNil())
	}
	if i.EvmEqualFold != nil {
		predicates = append(predicates, signer.EvmEqualFold(*i.EvmEqualFold))
	}
	if i.EvmContainsFold != nil {
		predicates = append(predicates, signer.EvmContainsFold(*i.EvmContainsFold))
	}
	if i.Points != nil {
		predicates = append(predicates, signer.PointsEQ(*i.Points))
	}
	if i.PointsNEQ != nil {
		predicates = append(predicates, signer.PointsNEQ(*i.PointsNEQ))
	}
	if len(i.PointsIn) > 0 {
		predicates = append(predicates, signer.PointsIn(i.PointsIn...))
	}
	if len(i.PointsNotIn) > 0 {
		predicates = append(predicates, signer.PointsNotIn(i.PointsNotIn...))
	}
	if i.PointsGT != nil {
		predicates = append(predicates, signer.PointsGT(*i.PointsGT))
	}
	if i.PointsGTE != nil {
		predicates = append(predicates, signer.PointsGTE(*i.PointsGTE))
	}
	if i.PointsLT != nil {
		predicates = append(predicates, signer.PointsLT(*i.PointsLT))
	}
	if i.PointsLTE != nil {
		predicates = append(predicates, signer.PointsLTE(*i.PointsLTE))
	}

	if i.HasAssetPrice != nil {
		p := signer.HasAssetPrice()
		if !*i.HasAssetPrice {
			p = signer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetPriceWith) > 0 {
		with := make([]predicate.AssetPrice, 0, len(i.HasAssetPriceWith))
		for _, w := range i.HasAssetPriceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetPriceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signer.HasAssetPriceWith(with...))
	}
	if i.HasEventLogs != nil {
		p := signer.HasEventLogs()
		if !*i.HasEventLogs {
			p = signer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventLogsWith) > 0 {
		with := make([]predicate.EventLog, 0, len(i.HasEventLogsWith))
		for _, w := range i.HasEventLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signer.HasEventLogsWith(with...))
	}
	if i.HasCorrectnessReport != nil {
		p := signer.HasCorrectnessReport()
		if !*i.HasCorrectnessReport {
			p = signer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCorrectnessReportWith) > 0 {
		with := make([]predicate.CorrectnessReport, 0, len(i.HasCorrectnessReportWith))
		for _, w := range i.HasCorrectnessReportWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCorrectnessReportWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signer.HasCorrectnessReportWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySignerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return signer.And(predicates...), nil
	}
}
